<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Eras Zombie - Europe</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a1128; color: #fff; font-family: 'Arial', sans-serif; overflow: hidden; }
        #gameCanvas { display: block; background: #1a2f4a; cursor: crosshair; }
        #ui { position: absolute; top: 15px; left: 15px; background: rgba(10, 17, 40, 0.95); padding: 20px; border-radius: 10px; min-width: 220px; border: 2px solid #d62828; box-shadow: 0 0 20px rgba(214, 40, 40, 0.3); }
        #playerName { padding: 10px; margin-bottom: 12px; border: 2px solid #555; border-radius: 6px; width: 100%; font-size: 14px; background: #1a1a1a; color: #fff; }
        #joinBtn { padding: 12px 24px; background: linear-gradient(135deg, #d62828 0%, #9d0208 100%); border: none; border-radius: 6px; color: white; cursor: pointer; width: 100%; font-size: 16px; font-weight: bold; text-transform: uppercase; letter-spacing: 1px; transition: all 0.3s; }
        #joinBtn:hover { background: linear-gradient(135deg, #9d0208 0%, #6a040f 100%); transform: translateY(-2px); box-shadow: 0 5px 15px rgba(214, 40, 40, 0.4); }
        .stat { margin: 10px 0; font-size: 14px; display: flex; justify-content: space-between; align-items: center; }
        .stat-label { color: #aaa; font-weight: 600; }
        .stat-value { color: #d62828; font-weight: bold; font-size: 16px; }
        #leaderboard { position: absolute; top: 15px; right: 15px; background: rgba(10, 17, 40, 0.95); padding: 20px; border-radius: 10px; min-width: 220px; max-height: 400px; overflow-y: auto; border: 2px solid #d62828; box-shadow: 0 0 20px rgba(214, 40, 40, 0.3); }
        .player-entry { padding: 8px 0; font-size: 13px; border-bottom: 1px solid rgba(255,255,255,0.1); }
        .player-entry:last-child { border-bottom: none; }
        #controls { position: absolute; bottom: 15px; left: 15px; background: rgba(10, 17, 40, 0.95); padding: 20px; border-radius: 10px; border: 2px solid #d62828; box-shadow: 0 0 20px rgba(214, 40, 40, 0.3); }
        #zoomControls { position: absolute; bottom: 15px; right: 15px; display: flex; gap: 10px; }
        .zoom-btn { background: rgba(10, 17, 40, 0.95); border: 2px solid #d62828; color: #fff; width: 50px; height: 50px; border-radius: 8px; font-size: 24px; cursor: pointer; transition: all 0.3s; display: flex; align-items: center; justify-content: center; }
        .zoom-btn:hover { background: #d62828; transform: scale(1.1); }
        h2 { margin-bottom: 12px; color: #d62828; font-size: 20px; text-shadow: 0 0 10px rgba(214, 40, 40, 0.5); text-transform: uppercase; letter-spacing: 2px; }
        .control-text { color: #aaa; font-size: 12px; line-height: 1.8; }
        .control-text strong { color: #d62828; }
        #mapTitle { position: absolute; top: 15px; left: 50%; transform: translateX(-50%); background: rgba(10, 17, 40, 0.95); padding: 15px 30px; border-radius: 10px; border: 2px solid #d62828; box-shadow: 0 0 20px rgba(214, 40, 40, 0.3); font-size: 24px; font-weight: bold; text-transform: uppercase; letter-spacing: 3px; color: #d62828; text-shadow: 0 0 10px rgba(214, 40, 40, 0.5); }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="mapTitle">üßü ERAS: ZOMBIE EUROPE üßü</div>
    <div id="ui">
        <h2>üõ°Ô∏è Command</h2>
        <input type="text" id="playerName" placeholder="Enter your name" maxlength="15">
        <button id="joinBtn">Join Battle</button>
        <div id="lobbyInfo" style="display:none;">
            <div class="stat"><span class="stat-label">Game starts in</span> <span class="stat-value" id="lobbyTimer">60</span>s</div>
            <div class="stat"><span class="stat-label">Players</span> <span class="stat-value" id="lobbyPlayerCount">0</span></div>
            <div class="stat"><span class="stat-label">Map</span> <span style="color: #aaa; font-size: 12px;" id="mapName">Europe</span></div>
        </div>
        <div id="spawnSelect" style="display:none;">
            <p style="color: #aaa; font-size: 13px; margin: 10px 0;">Click a territory in Western Europe to spawn</p>
        </div>
        <div id="stats" style="display:none;">
            <div class="stat"><span class="stat-label">Territory</span> <span class="stat-value" id="territory">0</span></div>
            <div class="stat"><span class="stat-label">Population</span> <span class="stat-value" id="population">0</span></div>
            <div class="stat"><span class="stat-label">Army</span> <span class="stat-value" id="army">0</span></div>
            <div class="stat"><span class="stat-label">üí∞ Gold</span> <span class="stat-value" id="gold">100</span></div>
            <div class="stat" style="margin-top: 15px;">
                <span class="stat-label">Troop %</span>
                <span class="stat-value" id="troopPercent">50</span>%
            </div>
            <input type="range" id="troopSlider" min="10" max="100" value="50" style="width: 100%; margin: 5px 0;">
        </div>
    </div>
    <div id="leaderboard"><h2>üèÜ Nations</h2><div id="players"></div></div>
    <div id="controls" style="display:none;">
        <div class="control-text">
            <strong>LEFT CLICK</strong> to expand (sand-fill)<br>
            <strong>RIGHT CLICK</strong> own territory for build menu<br>
            <strong>SLIDER</strong> controls % troops per attack<br>
            <strong>PVE:</strong> Defeat AI factions & zombies!
        </div>
    </div>
    <div id="buildMenu" style="display:none; position: absolute; background: rgba(10, 17, 40, 0.98); border: 2px solid #d62828; border-radius: 8px; padding: 15px; min-width: 200px; box-shadow: 0 0 20px rgba(214, 40, 40, 0.5); z-index: 1000;">
        <h3 style="color: #d62828; margin: 0 0 10px 0; font-size: 14px;">BUILD MENU</h3>
        <div id="buildOptions"></div>
    </div>
    <div id="zoomControls"><button class="zoom-btn" id="zoomOut">‚àí</button><button class="zoom-btn" id="zoomIn">+</button></div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        let socket, playerId = null;
        let gameState = { players: {}, territories: [], activeAttacks: [], aiFactions: {}, gamePhase: 'lobby', lobbyTimer: 60, mapName: 'Europe' };
        let zoom = 1.0, offsetX = 0, offsetY = 0;
        let selectingSpawn = false;
        let troopPercentage = 50;
        let selectedTerritory = null;

        const BUILDING_TYPES = {
            city: { cost: 150, name: 'City', emoji: 'üèõÔ∏è', desc: '+8 gold/tick, +30 pop bonus' },
            port: { cost: 200, name: 'Port', emoji: '‚öì', desc: '+15 gold/tick, trade routes' },
            train: { cost: 180, name: 'Train Station', emoji: 'üöÇ', desc: '+50% expansion speed' },
            factory: { cost: 250, name: 'Factory', emoji: 'üè≠', desc: '+40% army strength' },
            defensepost: { cost: 300, name: 'Defense Post', emoji: 'üè∞', desc: '+50 defense power' },
            missile: { cost: 500, name: 'Missile Silo', emoji: 'üöÄ', desc: 'Launch long-range attacks' }
        };
        
        document.getElementById('zoomIn').onclick = () => { zoom = Math.min(zoom * 1.2, 3.0); };
        document.getElementById('zoomOut').onclick = () => { zoom = Math.max(zoom / 1.2, 0.5); };
        
        function connect() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            socket = new WebSocket(protocol + '//' + window.location.host);
            socket.onopen = () => console.log('Connected');
            socket.onmessage = (event) => {
                const data = JSON.parse(event.data);
                if (data.type === 'init') { playerId = data.playerId; gameState = data.gameState; }
                else if (data.type === 'update') { gameState = data.gameState; }
                updateUI();
            };
            socket.onclose = () => setTimeout(connect, 2000);
        }
        
        document.getElementById('joinBtn').onclick = () => {
            const name = document.getElementById('playerName').value.trim() || 'Survivor';
            socket.send(JSON.stringify({ type: 'join', name: name }));
            document.getElementById('playerName').style.display = 'none';
            document.getElementById('joinBtn').style.display = 'none';
            document.getElementById('lobbyInfo').style.display = 'block';
        };

        document.getElementById('troopSlider').oninput = (e) => {
            troopPercentage = parseInt(e.target.value);
            document.getElementById('troopPercent').textContent = troopPercentage;
            socket.send(JSON.stringify({ type: 'setTroopPercentage', percentage: troopPercentage }));
        };
        
        canvas.onclick = (e) => {
            if (!playerId) return;
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left - canvas.width / 2) / zoom + canvas.width / 2 - offsetX;
            const y = (e.clientY - rect.top - canvas.height / 2) / zoom + canvas.height / 2 - offsetY;

            for (let territory of gameState.territories) {
                if (isPointInPolygon(x, y, territory.polygon)) {
                    if (selectingSpawn) {
                        // Spawn selection
                        socket.send(JSON.stringify({ type: 'selectSpawn', territoryId: territory.id }));
                        selectingSpawn = false;
                        document.getElementById('spawnSelect').style.display = 'none';
                        document.getElementById('stats').style.display = 'block';
                        document.getElementById('controls').style.display = 'block';
                    } else {
                        // Attack territory
                        socket.send(JSON.stringify({ type: 'attack', territoryId: territory.id }));
                    }
                    break;
                }
            }
        };

        canvas.oncontextmenu = (e) => {
            e.preventDefault();
            if (!playerId || selectingSpawn || gameState.gamePhase !== 'playing') return;

            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left - canvas.width / 2) / zoom + canvas.width / 2 - offsetX;
            const y = (e.clientY - rect.top - canvas.height / 2) / zoom + canvas.height / 2 - offsetY;

            for (let territory of gameState.territories) {
                if (isPointInPolygon(x, y, territory.polygon)) {
                    // Show build menu on own territory
                    if (territory.ownerId === playerId) {
                        selectedTerritory = territory;
                        showBuildMenu(e.clientX, e.clientY, territory);
                    }
                    break;
                }
            }
            return false;
        };

        // Close menu on left click
        canvas.addEventListener('click', () => {
            document.getElementById('buildMenu').style.display = 'none';
        });

        function showBuildMenu(x, y, territory) {
            const menu = document.getElementById('buildMenu');
            const options = document.getElementById('buildOptions');
            const player = gameState.players[playerId];

            if (!player) return;

            options.innerHTML = '';

            // Defense option
            if (territory.defense < 3) {
                const defBtn = document.createElement('button');
                defBtn.textContent = `üõ°Ô∏è Defense Lv${territory.defense + 1} (30 troops)`;
                defBtn.style.cssText = 'width: 100%; padding: 8px; margin: 4px 0; background: #2a4a5a; border: 1px solid #d62828; color: #fff; cursor: pointer; border-radius: 4px; font-size: 12px;';
                if (player.army < 30) defBtn.style.opacity = '0.5';
                defBtn.onclick = (e) => {
                    e.stopPropagation();
                    if (player.army >= 30) {
                        socket.send(JSON.stringify({ type: 'buildDefense', territoryId: territory.id }));
                        menu.style.display = 'none';
                    }
                };
                options.appendChild(defBtn);
            }

            // Building options
            Object.keys(BUILDING_TYPES).forEach(buildingType => {
                const building = BUILDING_TYPES[buildingType];
                if (territory.buildings && territory.buildings.includes(buildingType)) return;
                if (territory.buildings && territory.buildings.length >= 3) return;

                const btn = document.createElement('button');
                btn.textContent = `${building.emoji} ${building.name} (${building.cost} gold)`;
                btn.style.cssText = 'width: 100%; padding: 8px; margin: 4px 0; background: #2a4a5a; border: 1px solid #d62828; color: #fff; cursor: pointer; border-radius: 4px; font-size: 12px;';
                if (player.gold < building.cost) btn.style.opacity = '0.5';
                btn.title = building.desc;
                btn.onclick = (e) => {
                    e.stopPropagation();
                    if (player.gold >= building.cost) {
                        socket.send(JSON.stringify({ type: 'buildStructure', territoryId: territory.id, buildingType: buildingType }));
                        menu.style.display = 'none';
                    }
                };
                options.appendChild(btn);
            });

            menu.style.left = x + 'px';
            menu.style.top = y + 'px';
            menu.style.display = 'block';
        }
        
        function isPointInPolygon(x, y, polygon) {
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i][0], yi = polygon[i][1];
                const xj = polygon[j][0], yj = polygon[j][1];
                const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }
        
        function updateUI() {
            // Update lobby timer
            if (gameState.gamePhase === 'lobby') {
                document.getElementById('lobbyTimer').textContent = gameState.lobbyTimer;
                document.getElementById('lobbyPlayerCount').textContent = Object.keys(gameState.players).length;
                document.getElementById('mapName').textContent = gameState.mapName || 'Europe';
            }

            // Check if game just started
            if (gameState.gamePhase === 'playing' && document.getElementById('lobbyInfo').style.display !== 'none') {
                document.getElementById('lobbyInfo').style.display = 'none';
                document.getElementById('spawnSelect').style.display = 'block';
                document.getElementById('controls').style.display = 'block';
                selectingSpawn = true;
            }

            if (!playerId) return;
            const player = gameState.players[playerId];
            if (player) {
                // Check if player selected spawn
                if (player.spawnSelected && selectingSpawn) {
                    selectingSpawn = false;
                    document.getElementById('spawnSelect').style.display = 'none';
                    document.getElementById('stats').style.display = 'block';
                }

                document.getElementById('territory').textContent = player.territories || 0;
                document.getElementById('population').textContent = (player.population || 0).toLocaleString();
                document.getElementById('army').textContent = (player.army || 0).toLocaleString();
                document.getElementById('gold').textContent = (player.gold || 0).toLocaleString();
            }

            // Combine players and AI for leaderboard
            const allEntities = [
                ...Object.values(gameState.players),
                ...Object.values(gameState.aiFactions || {})
            ];
            const playersList = allEntities.sort((a, b) => b.territories - a.territories).slice(0, 10);
            document.getElementById('players').innerHTML = playersList.map((p, i) => {
                const medal = i === 0 ? 'ü•á' : i === 1 ? 'ü•à' : i === 2 ? 'ü•â' : `${i + 1}.`;
                const aiLabel = p.isAI ? ' (AI)' : '';
                return `<div class="player-entry" style="color: ${p.color}">${medal} ${p.name}${aiLabel} - ${p.territories} territories</div>`;
            }).join('');
        }
        
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(zoom, zoom);
            ctx.translate(-canvas.width / 2 + offsetX, -canvas.height / 2 + offsetY);

            for (let territory of gameState.territories) {
                const allPlayers = { ...gameState.players, ...(gameState.aiFactions || {}) };
                const owner = allPlayers[territory.ownerId];

                if (territory.polygon && territory.polygon.length > 0) {
                    ctx.beginPath();
                    ctx.moveTo(territory.polygon[0][0], territory.polygon[0][1]);
                    for (let i = 1; i < territory.polygon.length; i++) {
                        ctx.lineTo(territory.polygon[i][0], territory.polygon[i][1]);
                    }
                    ctx.closePath();

                    // Check if territory is being attacked (sand-fill effect)
                    const activeAttack = gameState.activeAttacks?.find(a => a.territoryId === territory.id);
                    const fillProgress = activeAttack ? activeAttack.progress : (territory.fillProgress || 0);

                    if (territory.isWater) {
                        // Water tiles - ocean blue gradient
                        const gradient = ctx.createRadialGradient(territory.x, territory.y, 0, territory.x, territory.y, 40);
                        gradient.addColorStop(0, '#1e5a7d');
                        gradient.addColorStop(1, '#0d3b52');
                        ctx.fillStyle = gradient;
                        ctx.fill();
                    } else if (territory.ownerId === 'zombie') {
                        ctx.fillStyle = '#2d4a2e';
                        ctx.fill();
                    } else if (owner) {
                        // Sand-fill style: show fill progress
                        const fillPercent = Math.min(fillProgress / 100, 1);
                        const gradient = ctx.createRadialGradient(territory.x, territory.y, 0, territory.x, territory.y, 80);
                        gradient.addColorStop(0, owner.color + Math.floor(fillPercent * 255).toString(16).padStart(2, '0'));
                        gradient.addColorStop(1, owner.color + Math.floor(fillPercent * 128).toString(16).padStart(2, '0'));
                        ctx.fillStyle = gradient;
                        ctx.fill();
                    } else {
                        // Neutral territory - greenish/brownish
                        ctx.fillStyle = '#3a4a3a';
                        ctx.fill();

                        // Show fill progress if being captured
                        if (activeAttack) {
                            const allPlayers = { ...gameState.players, ...(gameState.aiFactions || {}) };
                            const attacker = allPlayers[activeAttack.playerId];
                            if (attacker) {
                                ctx.fillStyle = attacker.color + '60'; // Semi-transparent
                                ctx.globalAlpha = fillProgress / 100;
                                ctx.fill();
                                ctx.globalAlpha = 1.0;
                            }
                        }
                    }

                    // Border
                    if (selectingSpawn && territory.region === 'west' && !territory.ownerId && !territory.isWater) {
                        ctx.strokeStyle = '#00ff00'; // Highlight spawn options
                        ctx.lineWidth = 3;
                    } else if (territory.isWater) {
                        ctx.strokeStyle = '#0a2a3d'; // Dark water border
                        ctx.lineWidth = 1;
                    } else {
                        ctx.strokeStyle = territory.ownerId === 'zombie' ? '#1a2f1b' : owner ? owner.color : '#2a3a2a';
                        ctx.lineWidth = 2;
                    }
                    ctx.stroke();
                }

                // Show defense structures
                if (territory.defense > 0 && territory.ownerId && territory.ownerId !== 'zombie') {
                    for (let i = 0; i < territory.defense; i++) {
                        ctx.fillStyle = '#ffd700';
                        ctx.font = 'bold 16px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        const offsetXPos = (i - 1) * 15;
                        ctx.fillText('üõ°Ô∏è', territory.x + offsetXPos, territory.y - 25);
                    }
                }

                // Show buildings
                if (territory.buildings && territory.buildings.length > 0 && territory.ownerId && territory.ownerId !== 'zombie') {
                    territory.buildings.forEach((buildingType, i) => {
                        const building = BUILDING_TYPES[buildingType];
                        if (building) {
                            ctx.fillStyle = '#ffd700';
                            ctx.font = 'bold 14px Arial';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            const offsetXPos = (i - 0.5) * 20;
                            ctx.fillText(building.emoji, territory.x + offsetXPos - 10, territory.y + 25);
                        }
                    });
                }

                // Zombie emoji
                if (territory.ownerId === 'zombie') {
                    ctx.fillStyle = '#8fb339';
                    ctx.font = 'bold 20px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('üßü', territory.x, territory.y);
                }

                // Population number
                if (territory.population > 0 && territory.ownerId && territory.ownerId !== 'zombie') {
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 13px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.shadowColor = 'rgba(0,0,0,0.8)';
                    ctx.shadowBlur = 3;
                    ctx.fillText(territory.population, territory.x, territory.y);
                    ctx.shadowBlur = 0;
                }

                // Country name (skip for water)
                if (territory.countryName && !territory.isWater) {
                    ctx.fillStyle = '#888';
                    ctx.font = '9px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(territory.countryName, territory.x, territory.y - 20);
                }

                // Show attack progress bar
                if (activeAttack) {
                    const allPlayers = { ...gameState.players, ...(gameState.aiFactions || {}) };
                    const attacker = allPlayers[activeAttack.playerId];
                    if (attacker) {
                        const barWidth = 60;
                        const barHeight = 6;
                        const barX = territory.x - barWidth / 2;
                        const barY = territory.y + 20;

                        // Background
                        ctx.fillStyle = '#333';
                        ctx.fillRect(barX, barY, barWidth, barHeight);

                        // Progress
                        ctx.fillStyle = attacker.color;
                        ctx.fillRect(barX, barY, (barWidth * activeAttack.progress) / 100, barHeight);

                        // Border
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(barX, barY, barWidth, barHeight);
                    }
                }
            }

            ctx.restore();
            requestAnimationFrame(render);
        }
        
        connect();
        render();
    </script>
</body>
</html>
